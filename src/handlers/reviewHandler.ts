/**
 * Review Handler
 * Handles review notifications, approval workflow, and response posting
 */

import { Context, Markup } from 'telegraf';
import { supabase, Review, App, AppWithAccount, Response } from '../services/supabase';
import { llmService } from '../services/llmService';
import { appStoreClient } from '../services/appStoreClient';
import { playStoreClient } from '../services/playStoreClient';
import { reviewLogger as logger } from '../utils/logger';

/**
 * Safely edit a message, handling "message is not modified" error
 */
async function safeEditMessage(
    ctx: Context,
    text: string,
    options?: Parameters<typeof ctx.editMessageText>[1]
): Promise<void> {
    try {
        await ctx.editMessageText(text, options);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : '';
        // Ignore "message is not modified" error - it's harmless
        if (errorMessage.includes('message is not modified')) {
            logger.debug('Message not modified (content unchanged), ignoring');
            return;
        }
        throw error;
    }
}

/**
 * Escape special characters for Telegram HTML
 * Escapes: < > & 
 */
function escapeHtml(text: string): string {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

/**
 * Format review date for display
 */
function formatReviewDate(dateString: string | null): string {
    if (!dateString) return '';

    const date = new Date(dateString);

    return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
}

/**
 * Build review notification message
 */
function buildReviewMessage(review: Review, app: App, response?: Response, modelName?: string): string {
    logger.debug('buildReviewMessage called', {
        reviewId: review.id,
        hasResponse: !!response,
        responseId: response?.id,
        hasAiText: !!response?.ai_generated_text,
        aiTextLength: response?.ai_generated_text?.length,
    });

    const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
    const stars = '‚≠ê'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);
    const versionInfo = review.app_version ? `, ${escapeHtml(review.app_version)}` : '';

    let message = `<b>${escapeHtml(app.name)} (${storeLabel}${versionInfo})</b>\n`;
    message += `${stars}\n\n`;

    // User info
    const reviewerName = review.reviewer_name || 'Anonymous';
    const territory = review.territory ? `, ${escapeHtml(review.territory)}` : '';
    message += `üë§ ${escapeHtml(reviewerName)}${territory}\n`;

    if (review.review_date) {
        message += `üìÖ ${formatReviewDate(review.review_date)}\n`;
    }

    message += `\n`;

    // Title and text
    if (review.title) {
        message += `<b>Title:</b> ${escapeHtml(review.title)}\n`;
    }

    message += `<blockquote>${escapeHtml(review.body)}</blockquote>`;

    if (response && response.ai_generated_text) {
        message += `\n\nüí¨ <b>Suggested Response:</b>\n<blockquote>${escapeHtml(response.ai_generated_text)}</blockquote>`;
        if (modelName) {
            message += `\n\nü§ñ <i>Generated by ${escapeHtml(modelName)}</i>`;
        }
        logger.debug('Added AI response to message', { responseLength: response.ai_generated_text.length });
    } else if (response) {
        logger.warn('Response exists but ai_generated_text is missing', { responseId: response.id });
    }

    return message;
}

/**
 * Build inline keyboard for review actions
 */
function buildReviewKeyboard(reviewId: string, hasResponse: boolean) {
    if (!hasResponse) {
        return Markup.inlineKeyboard([
            [Markup.button.callback('üîÑ Generate Response', `generate_${reviewId}`)],
            [Markup.button.callback('‚ùå Dismiss', `dismiss_${reviewId}`)],
        ]);
    }

    return Markup.inlineKeyboard([
        [
            Markup.button.callback('‚úÖ Approve', `approve_${reviewId}`),
            Markup.button.callback('‚úèÔ∏è Edit', `edit_${reviewId}`),
        ],
        [
            Markup.button.callback('üîÑ Regenerate', `regenerate_${reviewId}`),
            Markup.button.callback('‚ùå Reject', `reject_${reviewId}`),
        ],
    ]);
}

/**
 * Build inline keyboard for review iteration mode (with pagination buttons)
 */
function buildIteratorKeyboard(reviewId: string, hasResponse: boolean, currentIndex: number, total: number) {
    const rows = [];

    if (!hasResponse) {
        rows.push([
            Markup.button.callback('ü§ñ Generate AI Response', `iter_generate_${reviewId}`),
        ]);
        rows.push([
            Markup.button.callback('‚úèÔ∏è Write Response', `iter_write_${reviewId}`),
        ]);
    } else {
        rows.push([
            Markup.button.callback('‚úÖ Approve', `iter_approve_${reviewId}`),
            Markup.button.callback('‚úèÔ∏è Edit', `iter_edit_${reviewId}`),
        ]);
        rows.push([
            Markup.button.callback('üîÑ Regenerate', `iter_regenerate_${reviewId}`),
            Markup.button.callback('‚ùå Reject', `iter_reject_${reviewId}`),
        ]);
    }

    // Add pagination row
    const paginationRow = buildPaginationButtons(currentIndex, total);
    if (paginationRow.length > 0) {
        rows.push(paginationRow);
    }

    return Markup.inlineKeyboard(rows);
}

/**
 * Build pagination buttons for iterator mode
 * Shows page numbers with current page highlighted
 */
function buildPaginationButtons(currentIndex: number, total: number) {
    if (total <= 1) return [];

    const buttons = [];
    const maxButtons = 5; // Maximum number of page buttons to show
    const currentPage = currentIndex + 1; // 1-indexed for display

    // Calculate which pages to show
    let startPage = 1;
    let endPage = total;

    if (total > maxButtons) {
        // Center the current page when possible
        const halfMax = Math.floor(maxButtons / 2);
        startPage = Math.max(1, currentPage - halfMax);
        endPage = startPage + maxButtons - 1;

        if (endPage > total) {
            endPage = total;
            startPage = Math.max(1, endPage - maxButtons + 1);
        }
    }

    // Add "<<" button if not at start
    if (startPage > 1) {
        buttons.push(Markup.button.callback('¬´', `iter_goto_0`));
    }

    // Add page number buttons
    for (let page = startPage; page <= endPage; page++) {
        const index = page - 1; // Convert to 0-indexed
        if (page === currentPage) {
            // Current page - show as selected
            buttons.push(Markup.button.callback(`‚Ä¢ ${page} ‚Ä¢`, `iter_noop`));
        } else {
            buttons.push(Markup.button.callback(`${page}`, `iter_goto_${index}`));
        }
    }

    // Add ">>" button if not at end
    if (endPage < total) {
        buttons.push(Markup.button.callback('¬ª', `iter_goto_${total - 1}`));
    }

    return buttons;
}

/**
 * Build review message for iteration mode with counter
 */
function buildIteratorMessage(
    review: Review,
    app: App,
    currentIndex: number,
    total: number,
    response?: Response,
    modelName?: string
): string {
    logger.debug('buildIteratorMessage called', {
        reviewId: review.id,
        hasResponse: !!response,
        responseId: response?.id,
        hasAiText: !!response?.ai_generated_text,
        aiTextLength: response?.ai_generated_text?.length,
    });

    const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
    const stars = '‚≠ê'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);
    const versionInfo = review.app_version ? `, ${escapeHtml(review.app_version)}` : '';

    let message = `üìã <b>Review ${currentIndex + 1} of ${total}</b>\n\n`;
    message += `<b>${escapeHtml(app.name)} (${storeLabel}${versionInfo})</b>\n`;
    message += `${stars}\n\n`;

    // User info
    const reviewerName = review.reviewer_name || 'Anonymous';
    const territory = review.territory ? `, ${escapeHtml(review.territory)}` : '';
    message += `üë§ ${escapeHtml(reviewerName)}${territory}\n`;

    if (review.review_date) {
        message += `üìÖ ${formatReviewDate(review.review_date)}\n`;
    }

    message += `\n`;

    // Title and text
    if (review.title) {
        message += `<b>Title:</b> ${escapeHtml(review.title)}\n`;
    }

    message += `<blockquote>${escapeHtml(review.body)}</blockquote>`;

    if (response && response.ai_generated_text) {
        message += `\n\nüí¨ <b>Suggested Response:</b>\n<blockquote>${escapeHtml(response.ai_generated_text)}</blockquote>`;
        if (modelName) {
            message += `\n\nü§ñ <i>Generated by ${escapeHtml(modelName)}</i>`;
        }
    }

    return message;
}

/**
 * Send review notification to user
 */
export async function sendReviewNotification(
    ctx: Context,
    review: Review,
    app: App,
    response?: Response
): Promise<void> {
    const chatId = ctx.chat?.id;
    if (!chatId) return;

    const message = buildReviewMessage(review, app, response, llmService.getModel());
    const keyboard = buildReviewKeyboard(review.id, !!response);

    const sent = await ctx.reply(message, {
        parse_mode: 'HTML',
        ...keyboard,
    });

    // Save telegram message for later updates
    const user = await supabase.getUserByTelegramId(ctx.from!.id);
    if (user) {
        await supabase.saveTelegramMessage(review.id, user.id, chatId, sent.message_id);
    }

    // Update review status
    await supabase.updateReviewStatus(review.id, 'notified');
}

/**
 * Handle generate response action
 */
export async function handleGenerateResponse(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleGenerateResponse called', { reviewId });
    if (!ctx.callbackQuery) return;

    await ctx.answerCbQuery('Generating response...');

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        logger.warn('Review not found', { reviewId });
        await safeEditMessage(ctx, '‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        logger.warn('App not found', { appId: review.app_id });
        await safeEditMessage(ctx, '‚ùå App not found.');
        return;
    }

    try {
        // Get user
        const user = await supabase.getUserByTelegramId(ctx.from!.id);
        if (!user) {
            logger.warn('User not found', { telegramId: ctx.from!.id });
            await safeEditMessage(ctx, '‚ùå User not found.');
            return;
        }

        logger.debug('Generating AI response', { reviewId, appName: app.name, rating: review.rating });

        // Show typing indicator while generating
        await ctx.sendChatAction('typing');

        // Get user preferences for custom instructions
        const preferences = await supabase.getUserPreferences(user.id);
        const customInstructions = preferences?.preferences?.custom_instructions;

        // Generate AI response
        const aiResponse = await llmService.generateReviewResponse({
            appName: app.name,
            reviewRating: review.rating,
            reviewTitle: review.title,
            reviewBody: review.body,
            reviewerName: review.reviewer_name || undefined,
            store: review.store,
            customInstructions,
        });

        logger.debug('AI response generated', { reviewId, responseLength: aiResponse.length });

        // Check if response already exists (regenerate case)
        let response = await supabase.getResponseByReviewId(review.id);

        if (response) {
            // Update existing response
            logger.debug('Updating existing response', { reviewId, responseId: response.id });
            response = await supabase.updateResponse(response.id, {
                ai_generated_text: aiResponse,
                final_text: null, // Reset final text on regenerate
            });
        } else {
            // Create new response
            response = await supabase.createResponse({
                review_id: review.id,
                user_id: user.id,
                ai_generated_text: aiResponse,
            });
        }

        if (!response) {
            logger.error('Failed to save response', { reviewId });
            await safeEditMessage(ctx, '‚ùå Failed to save response. Please try again.');
            return;
        }

        logger.debug('Response saved', {
            reviewId,
            responseId: response.id,
            aiResponseText: response.ai_generated_text?.substring(0, 50) + '...',
        });

        // Update message with response
        const message = buildReviewMessage(review, app, response, llmService.getModel());
        logger.debug('Built message for update', {
            reviewId,
            messageLength: message.length,
            hasResponse: !!response,
            responseTextLength: response.ai_generated_text?.length,
        });

        const keyboard = buildReviewKeyboard(review.id, true);

        await safeEditMessage(ctx, message, {
            parse_mode: 'HTML',
            ...keyboard,
        });

        logger.debug('Message updated with response', { reviewId });
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        logger.error('Failed to generate response', { reviewId, error: errorMessage });
        await safeEditMessage(ctx, `‚ùå Failed to generate response: ${errorMessage}`);
    }
}

/**
 * Handle approve response action
 */
export async function handleApproveResponse(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleApproveResponse called', { reviewId });
    if (!ctx.callbackQuery) return;

    await ctx.answerCbQuery('Posting response...');

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        logger.warn('Review not found', { reviewId });
        await ctx.editMessageText('‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppWithAccount(review.app_id);
    if (!app) {
        logger.warn('App not found', { appId: review.app_id });
        await ctx.editMessageText('‚ùå App not found.');
        return;
    }

    if (!app.account || !app.account.is_valid) {
        logger.warn('Account invalid or missing', { appId: review.app_id, accountId: app.account_id });
        await ctx.editMessageText('‚ùå Account credentials are invalid. Please reconnect your account with /account.');
        return;
    }

    const response = await supabase.getResponseByReviewId(reviewId);
    if (!response) {
        logger.warn('Response not found', { reviewId });
        await ctx.editMessageText('‚ùå Response not found. Please generate one first.');
        return;
    }

    const responseText = response.final_text || response.ai_generated_text;
    logger.debug('Posting response to store', { reviewId, store: review.store, responseLength: responseText.length });

    try {
        // Post response to store
        if (review.store === 'app_store') {
            logger.debug('Posting to App Store', { reviewId, externalId: review.external_review_id });
            await appStoreClient.postResponseWithAccount(
                app.account,
                review.external_review_id,
                responseText
            );
        } else {
            logger.debug('Posting to Play Store', { reviewId, externalId: review.external_review_id });
            await playStoreClient.replyWithAccount(
                app.account,
                app.bundle_id!,
                review.external_review_id,
                responseText
            );
        }

        logger.info('Response posted successfully', { reviewId, store: review.store });

        // Update response status
        await supabase.approveResponse(response.id, responseText);
        await supabase.markResponsePosted(response.id);
        await supabase.updateReviewStatus(review.id, 'responded');

        const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';

        await safeEditMessage(ctx,
            `‚úÖ <b>Response Posted!</b>\n\n` +
            `<b>${escapeHtml(app.name)} (${storeLabel})</b>\n` +
            `${'‚≠ê'.repeat(review.rating)} by ${escapeHtml(review.reviewer_name || 'Anonymous')}\n\n` +
            `üí¨ <b>Posted Response:</b>\n<blockquote>${escapeHtml(responseText)}</blockquote>`,
            { parse_mode: 'HTML' }
        );
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        logger.error('Failed to post response', { reviewId, error: errorMessage });

        // Save error
        await supabase.markResponseFailed(response.id, errorMessage);
        await supabase.updateReviewStatus(review.id, 'failed');

        await safeEditMessage(ctx,
            `‚ùå <b>Failed to Post Response</b>\n\n` +
            `Error: ${escapeHtml(errorMessage)}\n\n` +
            `<i>Please check your account with /accounts</i>`,
            { parse_mode: 'HTML' }
        );
    }
}

/**
 * Handle edit response action
 */
export async function handleEditResponse(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleEditResponse called', { reviewId });
    if (!ctx.callbackQuery) return;

    await ctx.answerCbQuery();

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        logger.warn('Review not found', { reviewId });
        await ctx.reply('‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        await ctx.reply('‚ùå App not found.');
        return;
    }

    const response = await supabase.getResponseByReviewId(reviewId);
    if (!response) {
        await ctx.reply('‚ùå Response not found. Please generate one first.');
        return;
    }

    const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
    const stars = '‚≠ê'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);
    const currentResponse = response.final_text || response.ai_generated_text;

    await ctx.reply(
        '‚úèÔ∏è <b>Edit Response</b>\n\n' +
        `<b>${escapeHtml(app.name)} (${storeLabel})</b>\n` +
        `${stars} by ${escapeHtml(review.reviewer_name || 'Anonymous')}\n\n` +
        (review.title ? `<b>"${escapeHtml(review.title)}"</b>\n` : '') +
        `<blockquote>${escapeHtml(review.body)}</blockquote>\n\n` +
        'üí¨ <b>Current response:</b>\n' +
        `<blockquote>${escapeHtml(currentResponse)}</blockquote>\n\n` +
        'üìù Reply to this message with your edited response:',
        {
            parse_mode: 'HTML',
            reply_markup: {
                force_reply: true,
                selective: true,
            },
        }
    );

    // Store the response ID for the reply handler
    // This is handled in the main bot file
}

/**
 * Handle custom response from user reply
 */
export async function handleCustomResponse(
    ctx: Context,
    reviewId: string,
    customText: string
): Promise<void> {
    logger.debug('handleCustomResponse called', { reviewId, customTextLength: customText.length });
    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        logger.warn('Review not found', { reviewId });
        await ctx.reply('‚ùå Review not found.');
        return;
    }

    let response = await supabase.getResponseByReviewId(reviewId);

    // If no response exists (user writing custom response without AI generation), create one
    if (!response) {
        logger.debug('No existing response, creating new one for custom text', { reviewId });
        response = await supabase.createResponse({
            review_id: reviewId,
            user_id: review.user_id,
            ai_generated_text: customText, // Use custom text as the AI text since there's no AI response
            final_text: customText,
        });
    }

    logger.debug('Updating response with custom text', { reviewId, responseId: response.id });

    // Update the response with custom text
    await supabase.updateResponse(response.id, {
        final_text: customText,
    });

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        await ctx.reply('‚ùå App not found.');
        return;
    }

    const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
    const stars = '‚≠ê'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);

    await ctx.reply(
        '‚úÖ <b>Response Updated</b>\n\n' +
        `<b>${escapeHtml(app.name)} (${storeLabel})</b>\n` +
        `${stars} by ${escapeHtml(review.reviewer_name || 'Anonymous')}\n\n` +
        (review.title ? `<b>"${escapeHtml(review.title)}"</b>\n` : '') +
        `<blockquote>${escapeHtml(review.body)}</blockquote>\n\n` +
        'üí¨ <b>Your response:</b>\n' +
        `<blockquote>${escapeHtml(customText)}</blockquote>`,
        {
            parse_mode: 'HTML',
            ...Markup.inlineKeyboard([
                [Markup.button.callback('‚úÖ Approve & Post', `approve_${reviewId}`)],
                [Markup.button.callback('‚úèÔ∏è Edit Again', `edit_${reviewId}`)],
                [Markup.button.callback('‚ùå Cancel', `dismiss_${reviewId}`)],
            ]),
        }
    );
}

/**
 * Handle regenerate response action
 */
export async function handleRegenerateResponse(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleRegenerateResponse called', { reviewId });
    // Same as generate, but updates existing response
    await handleGenerateResponse(ctx, reviewId);
}

/**
 * Handle reject response action
 */
export async function handleRejectResponse(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleRejectResponse called', { reviewId });
    if (!ctx.callbackQuery) return;

    await ctx.answerCbQuery('Response rejected');

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        logger.warn('Review not found', { reviewId });
        await safeEditMessage(ctx, '‚ùå Review not found.');
        return;
    }

    logger.debug('Rejecting response', { reviewId });
    await supabase.updateReviewStatus(review.id, 'rejected');

    await safeEditMessage(ctx,
        '‚ùå <b>Response Rejected</b>\n\n' +
        'This review will not receive a response.',
        { parse_mode: 'HTML' }
    );
}

/**
 * Handle dismiss action
 */
export async function handleDismiss(ctx: Context, reviewId: string): Promise<void> {
    logger.debug('handleDismiss called', { reviewId });
    if (!ctx.callbackQuery) return;

    await ctx.answerCbQuery('Dismissed');

    const review = await supabase.getReviewById(reviewId);
    if (review) {
        logger.debug('Dismissing review', { reviewId });
        await supabase.updateReviewStatus(review.id, 'rejected');
    }

    await ctx.deleteMessage().catch(() => {
        // Message might already be deleted
        logger.debug('Message already deleted', { reviewId });
    });
}

// ============================================================================
// REVIEW ITERATOR MODE
// ============================================================================

// Store for tracking iterator state per user
const iteratorState = new Map<number, { reviewIds: string[]; currentIndex: number; selectedAppIds?: string[] }>();

// Store for tracking app filter selection per user
const appFilterState = new Map<number, { selectedAppIds: Set<string>; allApps: { id: string; name: string; store: string }[] }>();

/**
 * Build inline keyboard for app filter selection
 */
function buildAppFilterKeyboard(selectedAppIds: Set<string>, apps: { id: string; name: string; store: string }[]) {
    const rows = [];

    // App selection buttons
    for (const app of apps) {
        const isSelected = selectedAppIds.has(app.id);
        const storeLabel = app.store === 'app_store' ? 'iOS' : 'Android';
        const checkmark = isSelected ? '‚úÖ' : '‚¨ú';
        const label = `${checkmark} ${app.name} (${storeLabel})`;
        rows.push([Markup.button.callback(label, `filter_app_${app.id}`)]);
    }

    // Control buttons
    const controlRow = [];
    if (selectedAppIds.size === apps.length) {
        controlRow.push(Markup.button.callback('‚òê Deselect All', 'filter_deselect_all'));
    } else {
        controlRow.push(Markup.button.callback('‚òë Select All', 'filter_select_all'));
    }
    rows.push(controlRow);

    // Action buttons
    const hasSelection = selectedAppIds.size > 0;
    rows.push([
        Markup.button.callback(hasSelection ? '‚ñ∂Ô∏è Continue' : '‚ñ∂Ô∏è Show All', 'filter_continue'),
        Markup.button.callback('‚ùå Cancel', 'filter_cancel'),
    ]);

    return Markup.inlineKeyboard(rows);
}

/**
 * Build message for app filter selection
 */
function buildAppFilterMessage(selectedAppIds: Set<string>, apps: { id: string; name: string; store: string }[]): string {
    let message = 'üîç <b>Filter Reviews by App</b>\n\n';
    message += 'Select the apps you want to review:\n\n';

    for (const app of apps) {
        const isSelected = selectedAppIds.has(app.id);
        const storeLabel = app.store === 'app_store' ? 'iOS' : 'Android';
        const checkmark = isSelected ? '‚úÖ' : '‚¨ú';
        message += `${checkmark} <b>${escapeHtml(app.name)}</b> (${storeLabel})\n`;
    }

    message += `\n<i>Selected: ${selectedAppIds.size} of ${apps.length} apps</i>`;

    return message;
}

/**
 * Start review iterator - /review command handler
 */
export async function handleReviewCommand(ctx: Context): Promise<void> {
    logger.debug('handleReviewCommand called');
    const from = ctx.from;
    if (!from) {
        logger.warn('Unable to identify user');
        await ctx.reply('Unable to identify user.');
        return;
    }

    const user = await supabase.getUserByTelegramId(from.id);
    if (!user) {
        await ctx.reply('Please use /start first to register.');
        return;
    }

    // Get user's apps
    const apps = await supabase.getAppsByUser(user.id);

    if (apps.length === 0) {
        await ctx.reply(
            'üì± <b>No Apps Found</b>\n\n' +
            'You need to add apps first before reviewing.\n' +
            'Use /account to connect your developer account.',
            { parse_mode: 'HTML' }
        );
        return;
    }

    // If user has only one app, skip the filter UI
    if (apps.length === 1) {
        await startReviewIterator(ctx, from.id, user.id, [apps[0].id]);
        return;
    }

    // Show app filter selection UI
    const appList = apps.map(app => ({ id: app.id, name: app.name, store: app.store }));
    const selectedAppIds = new Set<string>(apps.map(app => app.id)); // Select all by default

    // Store filter state
    appFilterState.set(from.id, {
        selectedAppIds,
        allApps: appList,
    });

    const message = buildAppFilterMessage(selectedAppIds, appList);
    const keyboard = buildAppFilterKeyboard(selectedAppIds, appList);

    await ctx.reply(message, {
        parse_mode: 'HTML',
        ...keyboard,
    });
}

/**
 * Start the review iterator with selected app filters
 */
async function startReviewIterator(ctx: Context, telegramId: number, userId: string, appIds?: string[]): Promise<void> {
    const reviews = await supabase.getPendingReviewsByUser(userId, appIds);

    if (reviews.length === 0) {
        const filterText = appIds && appIds.length > 0 ? ' for the selected apps' : '';
        await ctx.reply(
            '‚úÖ <b>All Caught Up!</b>\n\n' +
            `There are no unresponded reviews${filterText}. Great job!`,
            { parse_mode: 'HTML' }
        );
        return;
    }

    // Store iterator state
    iteratorState.set(telegramId, {
        reviewIds: reviews.map((r: Review) => r.id),
        currentIndex: 0,
        selectedAppIds: appIds,
    });

    // Show first review
    await showIteratorReview(ctx, telegramId, 0);
}

/**
 * Handle app filter toggle callback
 */
export async function handleAppFilterToggle(ctx: Context, appId: string): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    const state = appFilterState.get(ctx.from.id);
    if (!state) {
        await ctx.answerCbQuery('Session expired. Please use /review again.');
        return;
    }

    // Toggle app selection
    if (state.selectedAppIds.has(appId)) {
        state.selectedAppIds.delete(appId);
    } else {
        state.selectedAppIds.add(appId);
    }

    await ctx.answerCbQuery();

    // Update message
    const message = buildAppFilterMessage(state.selectedAppIds, state.allApps);
    const keyboard = buildAppFilterKeyboard(state.selectedAppIds, state.allApps);

    await safeEditMessage(ctx, message, {
        parse_mode: 'HTML',
        ...keyboard,
    });
}

/**
 * Handle select all apps
 */
export async function handleAppFilterSelectAll(ctx: Context): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    const state = appFilterState.get(ctx.from.id);
    if (!state) {
        await ctx.answerCbQuery('Session expired. Please use /review again.');
        return;
    }

    // Select all apps
    state.selectedAppIds = new Set(state.allApps.map(app => app.id));

    await ctx.answerCbQuery('All apps selected');

    // Update message
    const message = buildAppFilterMessage(state.selectedAppIds, state.allApps);
    const keyboard = buildAppFilterKeyboard(state.selectedAppIds, state.allApps);

    await safeEditMessage(ctx, message, {
        parse_mode: 'HTML',
        ...keyboard,
    });
}

/**
 * Handle deselect all apps
 */
export async function handleAppFilterDeselectAll(ctx: Context): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    const state = appFilterState.get(ctx.from.id);
    if (!state) {
        await ctx.answerCbQuery('Session expired. Please use /review again.');
        return;
    }

    // Deselect all apps
    state.selectedAppIds = new Set();

    await ctx.answerCbQuery('All apps deselected');

    // Update message
    const message = buildAppFilterMessage(state.selectedAppIds, state.allApps);
    const keyboard = buildAppFilterKeyboard(state.selectedAppIds, state.allApps);

    await safeEditMessage(ctx, message, {
        parse_mode: 'HTML',
        ...keyboard,
    });
}

/**
 * Handle filter continue - start iterator with selected apps
 */
export async function handleAppFilterContinue(ctx: Context): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    const state = appFilterState.get(ctx.from.id);
    if (!state) {
        await ctx.answerCbQuery('Session expired. Please use /review again.');
        return;
    }

    await ctx.answerCbQuery();

    // Clean up filter state
    const selectedAppIds = state.selectedAppIds.size > 0
        ? Array.from(state.selectedAppIds)
        : undefined; // undefined means show all
    appFilterState.delete(ctx.from.id);

    // Delete the filter message
    await ctx.deleteMessage().catch(() => {
        logger.debug('Could not delete filter message');
    });

    // Get user and start iterator
    const user = await supabase.getUserByTelegramId(ctx.from.id);
    if (!user) {
        await ctx.reply('Please use /start first to register.');
        return;
    }

    await startReviewIterator(ctx, ctx.from.id, user.id, selectedAppIds);
}

/**
 * Handle filter cancel
 */
export async function handleAppFilterCancel(ctx: Context): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery('Cancelled');

    // Clean up filter state
    appFilterState.delete(ctx.from.id);

    // Delete the filter message
    await ctx.deleteMessage().catch(() => {
        logger.debug('Could not delete filter message');
    });
}

/**
 * Show review at specific index in iterator mode
 */
async function showIteratorReview(ctx: Context, telegramId: number, index: number, editMessage = false): Promise<void> {
    const state = iteratorState.get(telegramId);
    if (!state) {
        await ctx.reply('‚ùå Session expired. Please use /review to start again.');
        return;
    }

    if (index >= state.reviewIds.length) {
        // All reviews processed
        iteratorState.delete(telegramId);

        const message = '‚úÖ <b>All Done!</b>\n\n' +
            'You\'ve gone through all pending reviews. Great job!';

        if (editMessage) {
            await ctx.editMessageText(message, { parse_mode: 'HTML' });
        } else {
            await ctx.reply(message, { parse_mode: 'HTML' });
        }
        return;
    }

    const reviewId = state.reviewIds[index];
    const review = await supabase.getReviewById(reviewId);

    if (!review) {
        // Review was deleted, skip to next
        state.currentIndex = index + 1;
        await showIteratorReview(ctx, telegramId, index + 1, editMessage);
        return;
    }

    // Check if review is still pending
    if (!['pending', 'notified'].includes(review.status)) {
        // Review was already responded, skip to next
        state.currentIndex = index + 1;
        await showIteratorReview(ctx, telegramId, index + 1, editMessage);
        return;
    }

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        state.currentIndex = index + 1;
        await showIteratorReview(ctx, telegramId, index + 1, editMessage);
        return;
    }

    const response = await supabase.getResponseByReviewId(reviewId);
    state.currentIndex = index;

    logger.debug('showIteratorReview fetched response', {
        reviewId,
        index,
        hasResponse: !!response,
        responseId: response?.id,
        hasAiText: !!response?.ai_generated_text,
    });

    const message = buildIteratorMessage(
        review,
        app,
        index,
        state.reviewIds.length,
        response || undefined,
        response ? llmService.getModel() : undefined
    );
    const keyboard = buildIteratorKeyboard(reviewId, !!response, index, state.reviewIds.length);

    logger.debug('showIteratorReview built message', {
        reviewId,
        messageLength: message.length,
        hasResponseInKeyboard: !!response,
    });

    if (editMessage) {
        await safeEditMessage(ctx, message, {
            parse_mode: 'HTML',
            ...keyboard,
        });
    } else {
        await ctx.reply(message, {
            parse_mode: 'HTML',
            ...keyboard,
        });
    }
}

/**
 * Handle iterator generate response
 */
export async function handleIteratorGenerate(ctx: Context, reviewId: string): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery('Generating response...');

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        await ctx.editMessageText('‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        await ctx.editMessageText('‚ùå App not found.');
        return;
    }

    try {
        const user = await supabase.getUserByTelegramId(ctx.from.id);
        if (!user) {
            await ctx.editMessageText('‚ùå User not found.');
            return;
        }

        // Show typing indicator while generating
        await ctx.sendChatAction('typing');

        // Get user preferences for custom instructions
        const preferences = await supabase.getUserPreferences(user.id);
        const customInstructions = preferences?.preferences?.custom_instructions;

        const aiResponse = await llmService.generateReviewResponse({
            appName: app.name,
            reviewRating: review.rating,
            reviewTitle: review.title,
            reviewBody: review.body,
            reviewerName: review.reviewer_name || undefined,
            store: review.store,
            customInstructions,
        });

        // Check if response already exists (regenerate case)
        let response = await supabase.getResponseByReviewId(review.id);

        if (response) {
            // Update existing response
            response = await supabase.updateResponse(response.id, {
                ai_generated_text: aiResponse,
                final_text: null, // Reset final text on regenerate
            });
        } else {
            // Create new response
            response = await supabase.createResponse({
                review_id: review.id,
                user_id: user.id,
                ai_generated_text: aiResponse,
            });
        }

        logger.debug('handleIteratorGenerate response saved', {
            reviewId,
            responseId: response?.id,
            hasAiText: !!response?.ai_generated_text,
            currentIndex: iteratorState.get(ctx.from.id)?.currentIndex,
        });

        // Refresh the iterator view
        await showIteratorReview(ctx, ctx.from.id, iteratorState.get(ctx.from.id)?.currentIndex || 0, true);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        await ctx.editMessageText(`‚ùå Failed to generate response: ${errorMessage}`);
    }
}

/**
 * Handle iterator approve response
 */
export async function handleIteratorApprove(ctx: Context, reviewId: string): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery('Posting response...');

    const state = iteratorState.get(ctx.from.id);
    const currentIndex = state?.currentIndex || 0;

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        await ctx.editMessageText('‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppWithAccount(review.app_id);
    if (!app) {
        await ctx.editMessageText('‚ùå App not found.');
        return;
    }

    if (!app.account || !app.account.is_valid) {
        await ctx.editMessageText('‚ùå Account credentials are invalid. Please reconnect your account with /account.');
        return;
    }

    const response = await supabase.getResponseByReviewId(reviewId);
    if (!response) {
        await ctx.editMessageText('‚ùå Response not found. Please generate one first.');
        return;
    }

    const responseText = response.final_text || response.ai_generated_text;

    try {
        if (review.store === 'app_store') {
            await appStoreClient.postResponseWithAccount(
                app.account,
                review.external_review_id,
                responseText
            );
        } else {
            await playStoreClient.replyWithAccount(
                app.account,
                app.bundle_id!,
                review.external_review_id,
                responseText
            );
        }

        await supabase.approveResponse(response.id, responseText);
        await supabase.markResponsePosted(response.id);
        await supabase.updateReviewStatus(review.id, 'responded');

        // Show success
        await ctx.answerCbQuery('‚úÖ Response posted!');

        // Notify user with the posted response
        const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
        await ctx.reply(
            `‚úÖ <b>Response Posted!</b>\n\n` +
            `<b>${escapeHtml(app.name)} (${storeLabel})</b>\n` +
            `${'‚≠ê'.repeat(review.rating)} by ${escapeHtml(review.reviewer_name || 'Anonymous')}\n\n` +
            `üí¨ <b>Posted Response:</b>\n<blockquote>${escapeHtml(responseText)}</blockquote>`,
            { parse_mode: 'HTML' }
        );

        // Delete the current message and show next review
        if (state) {
            state.currentIndex = currentIndex + 1;

            // Delete the original review message
            await ctx.deleteMessage().catch(() => {
                // Message might already be deleted
                logger.debug('Message already deleted during iterator approve', { reviewId });
            });

            // Send new message with next review (editMessage = false since we deleted the original)
            await showIteratorReview(ctx, ctx.from.id, currentIndex + 1, false);
        }
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        await supabase.markResponseFailed(response.id, errorMessage);
        await supabase.updateReviewStatus(review.id, 'failed');
        await ctx.editMessageText(
            `‚ùå <b>Failed to Post Response</b>\n\nError: ${escapeHtml(errorMessage)}\n\n<i>Please check your account with /accounts</i>`,
            { parse_mode: 'HTML' }
        );
    }
}

/**
 * Handle iterator edit response
 */
export async function handleIteratorEdit(ctx: Context, reviewId: string): Promise<void> {
    // Same as regular edit, just store the review ID
    await handleEditResponse(ctx, reviewId);
}

/**
 * Handle iterator regenerate response
 */
export async function handleIteratorRegenerate(ctx: Context, reviewId: string): Promise<void> {
    await handleIteratorGenerate(ctx, reviewId);
}

/**
 * Handle iterator reject response
 */
export async function handleIteratorReject(ctx: Context, reviewId: string): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery('Rejected');

    const state = iteratorState.get(ctx.from.id);
    const currentIndex = state?.currentIndex || 0;

    const review = await supabase.getReviewById(reviewId);
    if (review) {
        await supabase.updateReviewStatus(review.id, 'rejected');
    }

    // Move to next review
    if (state) {
        state.currentIndex = currentIndex + 1;
        await showIteratorReview(ctx, ctx.from.id, currentIndex + 1, true);
    }
}

/**
 * Handle iterator goto - navigates to a specific review index
 */
export async function handleIteratorGoto(ctx: Context, index: number): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery();

    const state = iteratorState.get(ctx.from.id);
    if (!state) {
        await ctx.reply('‚ùå Session expired. Please use /review to start again.');
        return;
    }

    // Validate index bounds
    if (index < 0 || index >= state.reviewIds.length) {
        await ctx.answerCbQuery('Invalid page');
        return;
    }

    // Navigate to the specified index
    state.currentIndex = index;
    await showIteratorReview(ctx, ctx.from.id, index, true);
}

/**
 * Handle iterator write custom response (without AI)
 */
export async function handleIteratorWrite(ctx: Context, reviewId: string): Promise<void> {
    if (!ctx.callbackQuery || !ctx.from) return;

    await ctx.answerCbQuery();

    const review = await supabase.getReviewById(reviewId);
    if (!review) {
        await ctx.reply('‚ùå Review not found.');
        return;
    }

    const app = await supabase.getAppById(review.app_id);
    if (!app) {
        await ctx.reply('‚ùå App not found.');
        return;
    }

    const storeLabel = review.store === 'app_store' ? 'iOS' : 'Android';
    const stars = '‚≠ê'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);

    await ctx.reply(
        '‚úèÔ∏è <b>Write Your Response</b>\n\n' +
        `<b>${escapeHtml(app.name)} (${storeLabel})</b>\n` +
        `${stars} by ${escapeHtml(review.reviewer_name || 'Anonymous')}\n\n` +
        (review.title ? `<b>"${escapeHtml(review.title)}"</b>\n` : '') +
        `<blockquote>${escapeHtml(review.body)}</blockquote>\n\n` +
        'üìù Reply to this message with your response:',
        {
            parse_mode: 'HTML',
            reply_markup: {
                force_reply: true,
                selective: true,
            },
        }
    );
}
